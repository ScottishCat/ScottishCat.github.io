<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.1.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="Leetcode 25 Reverse Nodes in k-GroupGiven a linked list, reverse the nodes of a linked list k at a time and return its modified list. k is a positive integer and is less than or equal to the length of">
<meta name="keywords" content="Leetcode-Medium,LinkedList">
<meta property="og:type" content="article">
<meta property="og:title" content="Leetcode -- Linked List (Part 3)">
<meta property="og:url" content="http://yoursite.com/2019/05/31/LinkedList3/index.html">
<meta property="og:site_name" content="ScottishCat&#39;s Blog">
<meta property="og:description" content="Leetcode 25 Reverse Nodes in k-GroupGiven a linked list, reverse the nodes of a linked list k at a time and return its modified list. k is a positive integer and is less than or equal to the length of">
<meta property="og:locale" content="en">
<meta property="og:image" content="https://leetcode.com/problems/rotate-list/Figures/61/rotate.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2019/01/19/example_1_before_65p.jpg">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2019/01/19/example_1_after_65p.jpg">
<meta property="og:updated_time" content="2019-06-08T02:51:56.100Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Leetcode -- Linked List (Part 3)">
<meta name="twitter:description" content="Leetcode 25 Reverse Nodes in k-GroupGiven a linked list, reverse the nodes of a linked list k at a time and return its modified list. k is a positive integer and is less than or equal to the length of">
<meta name="twitter:image" content="https://leetcode.com/problems/rotate-list/Figures/61/rotate.png">



  <link rel="alternate" href="/atom.xml" title="ScottishCat's Blog" type="application/atom+xml">



  
  
  <link rel="canonical" href="http://yoursite.com/2019/05/31/LinkedList3/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Leetcode -- Linked List (Part 3) | ScottishCat's Blog</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
    <a href="https://github.com/ScottishCat/ScottishCat.github.io" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ScottishCat's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">Finish what we started.</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>About</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>Tags</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>Categories</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/31/LinkedList3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ScottishCat">
      <meta itemprop="description" content="A personal blog about algorithms, machine learning and big data.">
      <meta itemprop="image" content="http://ww1.sinaimg.cn/large/006tNc79ly1g36dxim4kej30dw0dwwfe.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ScottishCat's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Leetcode -- Linked List (Part 3)

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-05-31 08:45:20" itemprop="dateCreated datePublished" datetime="2019-05-31T08:45:20+08:00">2019-05-31</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-06-08 10:51:56" itemprop="dateModified" datetime="2019-06-08T10:51:56+08:00">2019-06-08</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Leetcode/" itemprop="url" rel="index"><span itemprop="name">Leetcode</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon">
            <i class="fa fa-eye"></i>
             Views:  
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="Leetcode-25-Reverse-Nodes-in-k-Group"><a href="#Leetcode-25-Reverse-Nodes-in-k-Group" class="headerlink" title="Leetcode 25 Reverse Nodes in k-Group"></a>Leetcode 25 Reverse Nodes in k-Group</h2><p>Given a linked list, reverse the nodes of a linked list <em>k</em> at a time and return its modified list.</p>
<p><em>k</em> is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of <em>k</em> then left-out nodes in the end should remain as it is.</p>
<a id="more"></a>
<p><strong>Example:</strong></p>
<p>Given this linked list: <code>1-&gt;2-&gt;3-&gt;4-&gt;5</code></p>
<p>For <em>k</em> = 2, you should return: <code>2-&gt;1-&gt;4-&gt;3-&gt;5</code></p>
<p>For <em>k</em> = 3, you should return: <code>3-&gt;2-&gt;1-&gt;4-&gt;5</code></p>
<p><strong>Note:</strong></p>
<ul>
<li>Only constant extra memory is allowed.</li>
<li>You may not alter the values in the list’s nodes, only nodes itself may be changed.</li>
</ul>
<p><strong>Solution</strong></p>
<p>We can solve this problem in a recurrsive way: </p>
<p>First, we reverses the first k nodes in the list. If the list has less than k nodes, then we undo the reversal.</p>
<p>If the list has more than k nodes, we need to find the <strong>next node</strong> in the list, set it as a new head and call the reversal function again. The time complexity is O(n) for reversing nodes requires O(n). Space Complexity is O(n/k) for the recurrsion has been called <strong>n/k</strong> times. When k is large, we can consider the space complexity as O(1).</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        ListNode current = head, prev = <span class="keyword">null</span>, next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// Stop until current reaches the end or has reversed k times</span></span><br><span class="line">        <span class="keyword">while</span> (current != <span class="keyword">null</span> &amp;&amp; count &lt; k)&#123;</span><br><span class="line">            next = current.next;</span><br><span class="line">            current.next = prev;</span><br><span class="line">            prev = current;</span><br><span class="line">            current = next;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//If the number of nodes is less than k, undo the reversal</span></span><br><span class="line">        <span class="keyword">if</span> (count &lt; k)&#123;</span><br><span class="line">            current = prev;</span><br><span class="line">            prev = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span>(current != <span class="keyword">null</span>)&#123;</span><br><span class="line">                next = current.next;</span><br><span class="line">                current.next = prev;</span><br><span class="line">                prev = current;</span><br><span class="line">                current = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//If there're nodes left, reverse them recurrsively</span></span><br><span class="line">        <span class="keyword">if</span> (current != <span class="keyword">null</span>)&#123;</span><br><span class="line">            head.next = reverseKGroup(current, k);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Time Complexity O(n)</p>
<p>Space Complexity O(n/k)  </p>
<h2 id="Leetcode-92-Reverse-Linked-List-II"><a href="#Leetcode-92-Reverse-Linked-List-II" class="headerlink" title="Leetcode 92 Reverse Linked List II"></a>Leetcode 92 Reverse Linked List II</h2><p>Reverse a linked list from position <em>m</em> to <em>n</em>. Do it in one-pass.</p>
<p><strong>Note:</strong> 1 ≤ <em>m</em> ≤ <em>n</em> ≤ length of list.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4</span><br><span class="line">Output: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</span><br></pre></td></tr></table></figure>
<p><strong>Solution</strong></p>
<p>To reverse particular section in one pass, we need 4 nodes, the head &amp; tail of the reversed section and two concatenation nodes. To do the reverse operation, we need to take the section out and put it back after we reversed it;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode tail = head, prev = <span class="keyword">null</span>, current = head, next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> len = n - m;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(m &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            prev = tail;</span><br><span class="line">            tail = tail.next;</span><br><span class="line">            current = current.next;</span><br><span class="line">            m--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            current = current.next;</span><br><span class="line">            len--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        next = current.next;</span><br><span class="line">        current.next = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Concate the head</span></span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="keyword">null</span>)&#123;</span><br><span class="line">             prev.next = reverse(tail);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            head = reverse(tail); <span class="comment">// Boundary case when m = 1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Concate the tail</span></span><br><span class="line">        tail.next = next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode next = head.next;</span><br><span class="line">            head.next = prev;</span><br><span class="line">            prev = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Time Complexity O(n)</p>
<p>Space Complexity O(1)</p>
<h2 id="Leetcode-109-Convert-Sorted-List-to-Binary-Search-Tree"><a href="#Leetcode-109-Convert-Sorted-List-to-Binary-Search-Tree" class="headerlink" title="Leetcode 109 Convert Sorted List to Binary Search Tree"></a>Leetcode 109 Convert Sorted List to Binary Search Tree</h2><p>Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.</p>
<p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of <em>every</em> node never differ by more than 1.</p>
<p><strong>Example:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Given the sorted linked list: [-10,-3,0,5,9],</span><br><span class="line"></span><br><span class="line">One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     / \</span><br><span class="line">   -3   9</span><br><span class="line">   /   /</span><br><span class="line"> -10  5</span><br></pre></td></tr></table></figure>
<p><strong>Solution</strong></p>
<p>(1) Recurrsive approach</p>
<p>the middle element of the given list would form the root of the binary search tree. All the elements to the left of the middle element would form the left subtree recursively. Similarly, all the elements to the right of the middle element will form the right subtree of the binary search tree. This would ensure the height balance required in the resulting binary search tree.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(head.val);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode slow = head, fast = head, previous = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            previous = slow;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(slow.val);</span><br><span class="line">        <span class="keyword">if</span> (previous != <span class="keyword">null</span>)&#123;</span><br><span class="line">            previous.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        root.left = sortedListToBST(head);</span><br><span class="line">        root.right = sortedListToBST(slow.next);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Time Complexity O(N logN)</p>
<p>it takes N/2N/2 steps to find the middle of a linked list with NN elements. After finding the middle element, we are left with two halves of size N / 2each. Then, we find the middle element for <code>both</code> of these halves and it would take a total of 2 times N / 4, 2×N/4 steps for that. And similarly for the smaller sublists that keep forming recursively. This would give us the following series of operations for a list of size N.</p>
<ul>
<li><p>Essentially, this is done log NlogN times since we split the linked list in half every time. Hence, the above equation becomes:</p>
<p>$\begin{aligned} &amp;\sum_{i = 1}^{\log N} 2^{i - 1} \cdot \frac{N}{2^i} \ = \; &amp;\sum_{i = 1}^{\log N}\frac{N}{2} \ = \; &amp;\frac{N}{2} \; \log N \ = \; &amp;O(N\log N) \end{aligned}$</p>
</li>
</ul>
<p>Space Complexity O(logN) </p>
<p>(2) Array approach</p>
<p>It takes N/2 steps to find the middle of linked list which is the drawback of linked list data structure. If we convert it into an array, we only need 1 step to find the middle of the list. However, this will require N extra memory for the newly created array.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> List&lt;Integer&gt; values;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.values = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mapListToValues</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.values.add(head.val);</span><br><span class="line">      head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> TreeNode <span class="title">convertListToBST</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Invalid case</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Middle element forms the root.</span></span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    TreeNode node = <span class="keyword">new</span> TreeNode(<span class="keyword">this</span>.values.get(mid));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Base case for when there is only one element left in the array</span></span><br><span class="line">    <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Recursively form BST on the two halves</span></span><br><span class="line">    node.left = convertListToBST(left, mid - <span class="number">1</span>);</span><br><span class="line">    node.right = convertListToBST(mid + <span class="number">1</span>, right);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Form an array out of the given linked list and then</span></span><br><span class="line">    <span class="comment">// use the array to form the BST.</span></span><br><span class="line">    <span class="keyword">this</span>.mapListToValues(head);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Convert the array to</span></span><br><span class="line">    <span class="keyword">return</span> convertListToBST(<span class="number">0</span>, <span class="keyword">this</span>.values.size() - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Time Complexity O(N)</p>
<p>Space Complexity O(N)</p>
<p>(3) Inorder magic</p>
<p>Elements processed in the inorder fashion on a binary search tree turn out to be sorted in ascending order. We know that the leftmost element in the inorder traversal has to be the head of our given linked list. Similarly, the next element in the inorder traversal will be the second element in the linked list and so on. This is made possible because the initial list given to us is sorted in ascending order.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> ListNode head;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findSize</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode ptr = head;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ptr != <span class="keyword">null</span>) &#123;</span><br><span class="line">      ptr = ptr.next;  </span><br><span class="line">      c += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> TreeNode <span class="title">convertListToBST</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Invalid case</span></span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// First step of simulated inorder traversal. Recursively form</span></span><br><span class="line">    <span class="comment">// the left half</span></span><br><span class="line">    TreeNode left = <span class="keyword">this</span>.convertListToBST(l, mid - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Once left half is traversed, process the current node</span></span><br><span class="line">    <span class="comment">// This step tries to find the leftmost node in the tree</span></span><br><span class="line">    <span class="comment">// This node is also the first node in the list</span></span><br><span class="line">    TreeNode node = <span class="keyword">new</span> TreeNode(<span class="keyword">this</span>.head.val);</span><br><span class="line">    node.left = left;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Maintain the invariance mentioned in the algorithm</span></span><br><span class="line">    <span class="keyword">this</span>.head = <span class="keyword">this</span>.head.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Recurse on the right hand side and form BST out of them</span></span><br><span class="line">    node.right = <span class="keyword">this</span>.convertListToBST(mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Get the size of the linked list first</span></span><br><span class="line">    <span class="keyword">int</span> size = <span class="keyword">this</span>.findSize(head);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.head = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Form the BST now that we know the size</span></span><br><span class="line">    <span class="keyword">return</span> convertListToBST(<span class="number">0</span>, size - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Time Complexity O(N)</p>
<p>Space Complexity O(log N)</p>
<h2 id="Leetcode-61-Rotate-List"><a href="#Leetcode-61-Rotate-List" class="headerlink" title="Leetcode 61 Rotate List"></a>Leetcode 61 Rotate List</h2><p>Given a linked list, rotate the list to the right by <em>k</em> places, where <em>k</em> is non-negative.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2</span><br><span class="line">Output: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</span><br><span class="line">Explanation:</span><br><span class="line">rotate 1 steps to the right: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL</span><br><span class="line">rotate 2 steps to the right: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</span><br></pre></td></tr></table></figure>
<p><strong>Solution</strong></p>
<p>The nodes in the list are already linked, and hence the rotation basically means</p>
<ul>
<li>To close the linked list into the ring.</li>
<li>To break the ring after the new tail and just in front of the new head.</li>
</ul>
<p><img src="https://leetcode.com/problems/rotate-list/Figures/61/rotate.png" alt="rotate"></p>
<p>new_head = (len - k) % len</p>
<p>new_tail = (len - k) % (len - 1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">rotateRight</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// base cases</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// close the linked list into the ring</span></span><br><span class="line">        ListNode old_tail = head;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">for</span>(n = <span class="number">1</span>; old_tail.next != <span class="keyword">null</span>; n++)&#123;</span><br><span class="line">            old_tail = old_tail.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        old_tail.next = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// find new tail : (n - k % n - 1)th node</span></span><br><span class="line">        <span class="comment">// and new head : (n - k % n)th node</span></span><br><span class="line">        ListNode new_tail = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - k % n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            new_tail = new_tail.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode new_head = new_tail.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// break the ring</span></span><br><span class="line">        new_tail.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> new_head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Time Complexity O(n)</p>
<p>Space Complexity O(1)</p>
<h2 id="Leetcode-82-Remove-Duplicates-from-Sorted-List-II"><a href="#Leetcode-82-Remove-Duplicates-from-Sorted-List-II" class="headerlink" title="Leetcode 82 Remove Duplicates from Sorted List II"></a>Leetcode 82 Remove Duplicates from Sorted List II</h2><p>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only <em>distinct</em> numbers from the original list.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5</span><br><span class="line">Output: 1-&gt;2-&gt;5</span><br></pre></td></tr></table></figure>
<p><strong>Solution</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode current = head;</span><br><span class="line">        <span class="comment">// if current node is duplicated (same as head), skip it.</span></span><br><span class="line">        <span class="keyword">if</span> (head.val == head.next.val)&#123;</span><br><span class="line">            <span class="keyword">while</span> (current != <span class="keyword">null</span> &amp;&amp; current.val == head.val)&#123;</span><br><span class="line">                current = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> deleteDuplicates(current);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// else recurrsively call the deleteDuplicates() function</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            head.next = deleteDuplicates(head.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Time Complexity O(n)</p>
<p>Space Complexity O(n) </p>
<h2 id="Leetcode-725-Split-Linked-List-in-Parts"><a href="#Leetcode-725-Split-Linked-List-in-Parts" class="headerlink" title="Leetcode 725 Split Linked List in Parts"></a>Leetcode 725 Split Linked List in Parts</h2><p>Given a (singly) linked list with head node <code>root</code>, write a function to split the linked list into <code>k</code> consecutive linked list “parts”.</p>
<p>The length of each part should be as equal as possible: no two parts should have a size differing by more than 1. This may lead to some parts being null.</p>
<p>The parts should be in order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal parts occurring later.</p>
<p>Return a List of ListNode’s representing the linked list parts that are formed.</p>
<p>Examples 1-&gt;2-&gt;3-&gt;4, k = 5 // 5 equal parts [ [1], [2], [3], [4], null ]</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">root = [1, 2, 3], k = 5</span><br><span class="line">Output: [[1],[2],[3],[],[]]</span><br><span class="line">Explanation:</span><br><span class="line">The input and each element of the output are ListNodes, not arrays.</span><br><span class="line">For example, the input root has root.val = 1, root.next.val = 2, \root.next.next.val = 3, and root.next.next.next = null.</span><br><span class="line">The first element output[0] has output[0].val = 1, output[0].next = null.</span><br><span class="line">The last element output[4] is null, but it&apos;s string representation as a ListNode is [].</span><br></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">root = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3</span><br><span class="line">Output: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]</span><br><span class="line">Explanation:</span><br><span class="line">The input has been split into consecutive parts with size difference at most 1, and earlier parts are a larger size than the later parts.</span><br></pre></td></tr></table></figure>
<p><strong>Note:</strong></p>
<p>The length of <code>root</code> will be in the range <code>[0, 1000]</code>.</p>
<p>Each value of a node in the input will be an integer in the range <code>[0, 999]</code>.</p>
<p><code>k</code> will be an integer in the range <code>[1, 50]</code>.</p>
<p><strong>Solution</strong></p>
<p>The key of this problem is to find the <strong>tail</strong> of each partition, If there are N nodes in the linked list <code>root</code>, then there are N / k items in each part, plus the first N % k parts have an extra item. We can count N with a simple loop.Now for each part, we have calculated how many nodes that part will have: <code>width + (i &lt; remainder ? 1 : 0)</code> , so the <strong>tail</strong> of each partition should be <code>width + (i &lt; remainder ? 1 : 0) - 1</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode[] splitListToParts(ListNode root, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        ListNode cur = root;</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            N++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> width = N / k, rem = N % k;</span><br><span class="line"></span><br><span class="line">        ListNode[] ans = <span class="keyword">new</span> ListNode[k];</span><br><span class="line">        cur = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            ListNode head = cur;</span><br><span class="line">            <span class="comment">// find the tail of each partition</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; width + (i &lt; rem ? <span class="number">1</span> : <span class="number">0</span>) - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur != <span class="keyword">null</span>) cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// split the list</span></span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ListNode prev = cur;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">                prev.next = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// record the head</span></span><br><span class="line">            ans[i] = head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Time Complexity: <strong>O(N+k)</strong>, where N is the number of nodes in the given list. If k is large, it could still require creating many new empty lists.</p>
<p>Space Complexity: <strong>O(k)</strong>, the additional space used in writing the answer.</p>
<h2 id="Leetcode-369-Plus-One-Linked-List"><a href="#Leetcode-369-Plus-One-Linked-List" class="headerlink" title="Leetcode 369 Plus One Linked List"></a>Leetcode 369 Plus One Linked List</h2><p>Given a non-negative integer represented as <strong>non-empty</strong> a singly linked list of digits, plus one to the integer.</p>
<p>You may assume the integer do not contain any leading zero, except the number 0 itself.</p>
<p>The digits are stored such that the most significant digit is at the head of the list.</p>
<p><strong>Example :</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line">Output: [1,2,4]</span><br></pre></td></tr></table></figure>
<p><strong>Solution</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">plusOne</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        Stack&lt;ListNode&gt; s = <span class="keyword">new</span> Stack&lt;ListNode&gt;();</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            s.push(cur);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">1</span>;</span><br><span class="line">        ListNode temp = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!s.isEmpty() || carry == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s.isEmpty())&#123;</span><br><span class="line">                ListNode node = temp;</span><br><span class="line">                temp = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">                temp.next = node;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                temp = s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            temp.val = temp.val + carry;</span><br><span class="line">            carry = (temp.val &gt;= <span class="number">10</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            temp.val = (temp.val &gt;= <span class="number">10</span>) ? temp.val % <span class="number">10</span> : temp.val;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Time Complexity O(n)</p>
<p>Space Complexity O(n)</p>
<h2 id="Leetcode-1019-Next-Greater-Node-In-Linked-List"><a href="#Leetcode-1019-Next-Greater-Node-In-Linked-List" class="headerlink" title="Leetcode 1019 Next Greater Node In Linked List"></a>Leetcode 1019 Next Greater Node In Linked List</h2><p>We are given a linked list with <code>head</code> as the first node.  Let’s number the nodes in the list: <code>node_1, node_2, node_3, ...</code> etc.</p>
<p>Each node may have a <em>next larger</em> <strong>value</strong>: for <code>node_i</code>, <code>next_larger(node_i)</code> is the <code>node_j.val</code> such that <code>j &gt; i</code>, <code>node_j.val &gt; node_i.val</code>, and <code>j</code> is the smallest possible choice.  If such a <code>j</code> does not exist, the next larger value is <code>0</code>.</p>
<p>Return an array of integers <code>answer</code>, where <code>answer[i] = next_larger(node_{i+1})</code>.</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,1,5]</span><br><span class="line">Output: [5,5,0]</span><br></pre></td></tr></table></figure>
<p><strong>Solution</strong></p>
<p>We can use two stacks <strong>stack &amp; max</strong>: one stores the elements in reversed order and one stores the current maximum value.</p>
<p><strong>Two stack approach</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextLargerNodes(ListNode head) &#123;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;ListNode&gt; max = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> length = stack.size();</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            ListNode top = stack.pop();</span><br><span class="line">            <span class="keyword">while</span> (!max.isEmpty() &amp;&amp; max.peek().val &lt;= top.val)&#123;</span><br><span class="line">                max.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!max.isEmpty())&#123;</span><br><span class="line">                result[i] = max.peek().val;</span><br><span class="line">            &#125;</span><br><span class="line">            max.push(top);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> Time Complexity O(n)</p>
<p>Space Complexity O(n)</p>
<p><strong>Monotonous stack approach</strong></p>
<p>A monotone Stack/Queue is a data structure the elements from the front to the end is strictly either increasing or decreasing</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">index   v   Increasing queue        Decreasing queue</span><br><span class="line">1       5   [5]                     [5]</span><br><span class="line">2       3   [3] 3 kick out 5        [5, 3] #3-&gt;5</span><br><span class="line">3       1   [1] 1 kick out 3        [5, 3, 1] #1-&gt;3</span><br><span class="line">4       2   [1, 2] #2-&gt;1            [5, 3, 2] 2 kick out 1 #2-&gt;3</span><br><span class="line">5       4   [1, 2, 4] #4-&gt;2         [5,4] 4 kick out 2, 3 #4-&gt;2</span><br></pre></td></tr></table></figure>
<p>Monotone Stack/Queue is ususlly used to find <em>next/previous larger/ smaller node</em> problem. We can solve these kind of problem by maintaining a monotone stack (store the index instead of value)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextLargerNodes(ListNode head) &#123;</span><br><span class="line">        List &lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stack &lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            list.add(head.val);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = list.size();</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; list.get(i) &gt; list.get(stack.peek()))&#123;</span><br><span class="line">                result[stack.pop()] = list.get(i);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Time Complexity O(n)</p>
<p>Space Compelxity O(n)</p>
<h2 id="Leetcode-708-Insert-into-a-Cyclic-Sorted-List"><a href="#Leetcode-708-Insert-into-a-Cyclic-Sorted-List" class="headerlink" title="Leetcode 708 Insert into a Cyclic Sorted List"></a>Leetcode 708 Insert into a Cyclic Sorted List</h2><p>Given a node from a cyclic linked list which is sorted in ascending order, write a function to insert a value into the list such that it remains a cyclic sorted list. The given node can be a reference to <em>any</em> single node in the list, and may not be necessarily the smallest value in the cyclic list.</p>
<p>If there are multiple suitable places for insertion, you may choose any place to insert the new value. After the insertion, the cyclic list should remain sorted.</p>
<p>If the list is empty (i.e., given node is <code>null</code>), you should create a new single cyclic list and return the reference to that single node. Otherwise, you should return the original given node.</p>
<p>The following example may help you understand the problem better:</p>
<p><img src="https://assets.leetcode.com/uploads/2019/01/19/example_1_before_65p.jpg" alt="img"></p>
<p>In the figure above, there is a cyclic sorted list of three elements. You are given a reference to the node with value 3, and we need to insert 2 into the list.</p>
<p><img src="https://assets.leetcode.com/uploads/2019/01/19/example_1_after_65p.jpg" alt="img"></p>
<p><strong>Solution</strong></p>
<p>There’re two possible situations: </p>
<p>(1) <strong>min(list) &lt;= insertVal &lt;= max(list)</strong> -&gt; insert between <strong>current</strong> and <strong>current.next</strong></p>
<p>(2) <strong>insertVal &gt; max(list) || insertVal &lt; min(list)</strong>  -&gt; insert after the maximum node</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">insert</span><span class="params">(Node head, <span class="keyword">int</span> insertVal)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// null situation</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            Node result = <span class="keyword">new</span> Node(insertVal, <span class="keyword">null</span>);</span><br><span class="line">            result.next = result;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Node cur = head;</span><br><span class="line">        Node max = cur;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (insertVal &gt;= cur.val &amp;&amp; insertVal &lt;= cur.next.val)&#123;</span><br><span class="line">                <span class="comment">// insert between cur and cur.next</span></span><br><span class="line">                Node insert = <span class="keyword">new</span> Node(insertVal,cur.next); </span><br><span class="line">                cur.next = insert;</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (cur.val &gt;= max.val)&#123;</span><br><span class="line">                max = cur;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// reaches the end of the list</span></span><br><span class="line">            <span class="keyword">if</span> (cur.next == head)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// insert after the maximum node</span></span><br><span class="line">        Node insert = <span class="keyword">new</span> Node(insertVal, max.next);</span><br><span class="line">        max.next = insert;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Time Complexity O(n)</p>
<p>Space Compelxity O(1)</p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Leetcode-Medium/" rel="tag"># Leetcode-Medium</a>
          
            <a href="/tags/LinkedList/" rel="tag"># LinkedList</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/05/25/LinkedList2/" rel="next" title="Leetcode -- Linked List (Part 2)">
                <i class="fa fa-chevron-left"></i> Leetcode -- Linked List (Part 2)
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/06/08/Stack1/" rel="prev" title="Leetcode -- Stack (Part 1)">
                Leetcode -- Stack (Part 1) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="http://ww1.sinaimg.cn/large/006tNc79ly1g36dxim4kej30dw0dwwfe.jpg" alt="ScottishCat">
            
              <p class="site-author-name" itemprop="name">ScottishCat</p>
              <div class="site-description motion-element" itemprop="description">A personal blog about algorithms, machine learning and big data.</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">9</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">3</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">7</span>
                    <span class="site-state-item-name">tags</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Leetcode-25-Reverse-Nodes-in-k-Group"><span class="nav-number">1.</span> <span class="nav-text">Leetcode 25 Reverse Nodes in k-Group</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Leetcode-92-Reverse-Linked-List-II"><span class="nav-number">2.</span> <span class="nav-text">Leetcode 92 Reverse Linked List II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Leetcode-109-Convert-Sorted-List-to-Binary-Search-Tree"><span class="nav-number">3.</span> <span class="nav-text">Leetcode 109 Convert Sorted List to Binary Search Tree</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Leetcode-61-Rotate-List"><span class="nav-number">4.</span> <span class="nav-text">Leetcode 61 Rotate List</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Leetcode-82-Remove-Duplicates-from-Sorted-List-II"><span class="nav-number">5.</span> <span class="nav-text">Leetcode 82 Remove Duplicates from Sorted List II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Leetcode-725-Split-Linked-List-in-Parts"><span class="nav-number">6.</span> <span class="nav-text">Leetcode 725 Split Linked List in Parts</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Leetcode-369-Plus-One-Linked-List"><span class="nav-number">7.</span> <span class="nav-text">Leetcode 369 Plus One Linked List</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Leetcode-1019-Next-Greater-Node-In-Linked-List"><span class="nav-number">8.</span> <span class="nav-text">Leetcode 1019 Next Greater Node In Linked List</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Leetcode-708-Insert-into-a-Cyclic-Sorted-List"><span class="nav-number">9.</span> <span class="nav-text">Leetcode 708 Insert into a Cyclic Sorted List</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ScottishCat</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.1.1</div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="Total Visitors">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="post-meta-divider">|</span>
  

  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="Total Views">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>














  
    
    
  
  <script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script>













  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.1"></script>

  <script src="/js/motion.js?v=7.1.1"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.1.1"></script>




  
  <script src="/js/scrollspy.js?v=7.1.1"></script>
<script src="/js/post-details.js?v=7.1.1"></script>



  


  <script src="/js/next-boot.js?v=7.1.1"></script>


  

  

  

  


  


  




  

  

  

  

  

  

  

  

  

  

  

  
<script>
  $('.highlight').not('.gist .highlight').each(function(i, e) {
    var $wrap = $('<div>').addClass('highlight-wrap');
    $(e).after($wrap);
    $wrap.append($('<button>').addClass('copy-btn').append('Copy').on('click', function(e) {
      var code = $(this).parent().find('.code').find('.line').map(function(i, e) {
        return $(e).text();
      }).toArray().join('\n');
      var ta = document.createElement('textarea');
      var yPosition = window.pageYOffset || document.documentElement.scrollTop;
      ta.style.top = yPosition + 'px'; // Prevent page scroll
      ta.style.position = 'absolute';
      ta.style.opacity = '0';
      ta.readOnly = true;
      ta.value = code;
      document.body.appendChild(ta);
      ta.select();
      ta.setSelectionRange(0, code.length);
      ta.readOnly = false;
      var result = document.execCommand('copy');
      
      ta.blur(); // For iOS
      $(this).blur();
    })).on('mouseleave', function(e) {
      var $b = $(this).find('.copy-btn');
      setTimeout(function() {
        $b.text('Copy');
      }, 300);
    }).append(e);
  })
</script>


  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"left","width":250,"height":500,"hOffset":10,"vOffset":0},"mobile":{"show":true},"algolia":null,"applicationID":"Your application ID","apiKey":"Your Search-Only API Key","indexName":"Your Index Name","log":false,"tagMode":false});</script></body>
</html>
