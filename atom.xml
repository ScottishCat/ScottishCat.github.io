<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ScottishCat&#39;s Blog</title>
  
  <subtitle>Finish what we started.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-06-08T02:51:56.100Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>ScottishCat</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leetcode -- Linked List (Part 3)</title>
    <link href="http://yoursite.com/2019/05/31/LinkedList3/"/>
    <id>http://yoursite.com/2019/05/31/LinkedList3/</id>
    <published>2019-05-31T00:45:20.000Z</published>
    <updated>2019-06-08T02:51:56.100Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-25-Reverse-Nodes-in-k-Group"><a href="#Leetcode-25-Reverse-Nodes-in-k-Group" class="headerlink" title="Leetcode 25 Reverse Nodes in k-Group"></a>Leetcode 25 Reverse Nodes in k-Group</h2><p>Given a linked list, reverse the nodes of a linked list <em>k</em> at a time and return its modified list.</p><p><em>k</em> is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of <em>k</em> then left-out nodes in the end should remain as it is.</p><a id="more"></a><p><strong>Example:</strong></p><p>Given this linked list: <code>1-&gt;2-&gt;3-&gt;4-&gt;5</code></p><p>For <em>k</em> = 2, you should return: <code>2-&gt;1-&gt;4-&gt;3-&gt;5</code></p><p>For <em>k</em> = 3, you should return: <code>3-&gt;2-&gt;1-&gt;4-&gt;5</code></p><p><strong>Note:</strong></p><ul><li>Only constant extra memory is allowed.</li><li>You may not alter the values in the list’s nodes, only nodes itself may be changed.</li></ul><p><strong>Solution</strong></p><p>We can solve this problem in a recurrsive way: </p><p>First, we reverses the first k nodes in the list. If the list has less than k nodes, then we undo the reversal.</p><p>If the list has more than k nodes, we need to find the <strong>next node</strong> in the list, set it as a new head and call the reversal function again. The time complexity is O(n) for reversing nodes requires O(n). Space Complexity is O(n/k) for the recurrsion has been called <strong>n/k</strong> times. When k is large, we can consider the space complexity as O(1).</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        ListNode current = head, prev = <span class="keyword">null</span>, next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// Stop until current reaches the end or has reversed k times</span></span><br><span class="line">        <span class="keyword">while</span> (current != <span class="keyword">null</span> &amp;&amp; count &lt; k)&#123;</span><br><span class="line">            next = current.next;</span><br><span class="line">            current.next = prev;</span><br><span class="line">            prev = current;</span><br><span class="line">            current = next;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//If the number of nodes is less than k, undo the reversal</span></span><br><span class="line">        <span class="keyword">if</span> (count &lt; k)&#123;</span><br><span class="line">            current = prev;</span><br><span class="line">            prev = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span>(current != <span class="keyword">null</span>)&#123;</span><br><span class="line">                next = current.next;</span><br><span class="line">                current.next = prev;</span><br><span class="line">                prev = current;</span><br><span class="line">                current = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//If there're nodes left, reverse them recurrsively</span></span><br><span class="line">        <span class="keyword">if</span> (current != <span class="keyword">null</span>)&#123;</span><br><span class="line">            head.next = reverseKGroup(current, k);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Time Complexity O(n)</p><p>Space Complexity O(n/k)  </p><h2 id="Leetcode-92-Reverse-Linked-List-II"><a href="#Leetcode-92-Reverse-Linked-List-II" class="headerlink" title="Leetcode 92 Reverse Linked List II"></a>Leetcode 92 Reverse Linked List II</h2><p>Reverse a linked list from position <em>m</em> to <em>n</em>. Do it in one-pass.</p><p><strong>Note:</strong> 1 ≤ <em>m</em> ≤ <em>n</em> ≤ length of list.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4</span><br><span class="line">Output: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</span><br></pre></td></tr></table></figure><p><strong>Solution</strong></p><p>To reverse particular section in one pass, we need 4 nodes, the head &amp; tail of the reversed section and two concatenation nodes. To do the reverse operation, we need to take the section out and put it back after we reversed it;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode tail = head, prev = <span class="keyword">null</span>, current = head, next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> len = n - m;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(m &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            prev = tail;</span><br><span class="line">            tail = tail.next;</span><br><span class="line">            current = current.next;</span><br><span class="line">            m--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            current = current.next;</span><br><span class="line">            len--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        next = current.next;</span><br><span class="line">        current.next = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Concate the head</span></span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="keyword">null</span>)&#123;</span><br><span class="line">             prev.next = reverse(tail);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            head = reverse(tail); <span class="comment">// Boundary case when m = 1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Concate the tail</span></span><br><span class="line">        tail.next = next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode next = head.next;</span><br><span class="line">            head.next = prev;</span><br><span class="line">            prev = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Time Complexity O(n)</p><p>Space Complexity O(1)</p><h2 id="Leetcode-109-Convert-Sorted-List-to-Binary-Search-Tree"><a href="#Leetcode-109-Convert-Sorted-List-to-Binary-Search-Tree" class="headerlink" title="Leetcode 109 Convert Sorted List to Binary Search Tree"></a>Leetcode 109 Convert Sorted List to Binary Search Tree</h2><p>Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.</p><p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of <em>every</em> node never differ by more than 1.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Given the sorted linked list: [-10,-3,0,5,9],</span><br><span class="line"></span><br><span class="line">One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:</span><br><span class="line"></span><br><span class="line">      0</span><br><span class="line">     / \</span><br><span class="line">   -3   9</span><br><span class="line">   /   /</span><br><span class="line"> -10  5</span><br></pre></td></tr></table></figure><p><strong>Solution</strong></p><p>(1) Recurrsive approach</p><p>the middle element of the given list would form the root of the binary search tree. All the elements to the left of the middle element would form the left subtree recursively. Similarly, all the elements to the right of the middle element will form the right subtree of the binary search tree. This would ensure the height balance required in the resulting binary search tree.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(head.val);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode slow = head, fast = head, previous = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            previous = slow;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(slow.val);</span><br><span class="line">        <span class="keyword">if</span> (previous != <span class="keyword">null</span>)&#123;</span><br><span class="line">            previous.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        root.left = sortedListToBST(head);</span><br><span class="line">        root.right = sortedListToBST(slow.next);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Time Complexity O(N logN)</p><p>it takes N/2N/2 steps to find the middle of a linked list with NN elements. After finding the middle element, we are left with two halves of size N / 2each. Then, we find the middle element for <code>both</code> of these halves and it would take a total of 2 times N / 4, 2×N/4 steps for that. And similarly for the smaller sublists that keep forming recursively. This would give us the following series of operations for a list of size N.</p><ul><li><p>Essentially, this is done log NlogN times since we split the linked list in half every time. Hence, the above equation becomes:</p><p>$\begin{aligned} &amp;\sum_{i = 1}^{\log N} 2^{i - 1} \cdot \frac{N}{2^i} \ = \; &amp;\sum_{i = 1}^{\log N}\frac{N}{2} \ = \; &amp;\frac{N}{2} \; \log N \ = \; &amp;O(N\log N) \end{aligned}$</p></li></ul><p>Space Complexity O(logN) </p><p>(2) Array approach</p><p>It takes N/2 steps to find the middle of linked list which is the drawback of linked list data structure. If we convert it into an array, we only need 1 step to find the middle of the list. However, this will require N extra memory for the newly created array.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> List&lt;Integer&gt; values;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.values = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mapListToValues</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.values.add(head.val);</span><br><span class="line">      head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> TreeNode <span class="title">convertListToBST</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Invalid case</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Middle element forms the root.</span></span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    TreeNode node = <span class="keyword">new</span> TreeNode(<span class="keyword">this</span>.values.get(mid));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Base case for when there is only one element left in the array</span></span><br><span class="line">    <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">      <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Recursively form BST on the two halves</span></span><br><span class="line">    node.left = convertListToBST(left, mid - <span class="number">1</span>);</span><br><span class="line">    node.right = convertListToBST(mid + <span class="number">1</span>, right);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Form an array out of the given linked list and then</span></span><br><span class="line">    <span class="comment">// use the array to form the BST.</span></span><br><span class="line">    <span class="keyword">this</span>.mapListToValues(head);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Convert the array to</span></span><br><span class="line">    <span class="keyword">return</span> convertListToBST(<span class="number">0</span>, <span class="keyword">this</span>.values.size() - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Time Complexity O(N)</p><p>Space Complexity O(N)</p><p>(3) Inorder magic</p><p>Elements processed in the inorder fashion on a binary search tree turn out to be sorted in ascending order. We know that the leftmost element in the inorder traversal has to be the head of our given linked list. Similarly, the next element in the inorder traversal will be the second element in the linked list and so on. This is made possible because the initial list given to us is sorted in ascending order.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> ListNode head;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findSize</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode ptr = head;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ptr != <span class="keyword">null</span>) &#123;</span><br><span class="line">      ptr = ptr.next;  </span><br><span class="line">      c += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> TreeNode <span class="title">convertListToBST</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Invalid case</span></span><br><span class="line">    <span class="keyword">if</span> (l &gt; r) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// First step of simulated inorder traversal. Recursively form</span></span><br><span class="line">    <span class="comment">// the left half</span></span><br><span class="line">    TreeNode left = <span class="keyword">this</span>.convertListToBST(l, mid - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Once left half is traversed, process the current node</span></span><br><span class="line">    <span class="comment">// This step tries to find the leftmost node in the tree</span></span><br><span class="line">    <span class="comment">// This node is also the first node in the list</span></span><br><span class="line">    TreeNode node = <span class="keyword">new</span> TreeNode(<span class="keyword">this</span>.head.val);</span><br><span class="line">    node.left = left;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Maintain the invariance mentioned in the algorithm</span></span><br><span class="line">    <span class="keyword">this</span>.head = <span class="keyword">this</span>.head.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Recurse on the right hand side and form BST out of them</span></span><br><span class="line">    node.right = <span class="keyword">this</span>.convertListToBST(mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Get the size of the linked list first</span></span><br><span class="line">    <span class="keyword">int</span> size = <span class="keyword">this</span>.findSize(head);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.head = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Form the BST now that we know the size</span></span><br><span class="line">    <span class="keyword">return</span> convertListToBST(<span class="number">0</span>, size - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Time Complexity O(N)</p><p>Space Complexity O(log N)</p><h2 id="Leetcode-61-Rotate-List"><a href="#Leetcode-61-Rotate-List" class="headerlink" title="Leetcode 61 Rotate List"></a>Leetcode 61 Rotate List</h2><p>Given a linked list, rotate the list to the right by <em>k</em> places, where <em>k</em> is non-negative.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2</span><br><span class="line">Output: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</span><br><span class="line">Explanation:</span><br><span class="line">rotate 1 steps to the right: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL</span><br><span class="line">rotate 2 steps to the right: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</span><br></pre></td></tr></table></figure><p><strong>Solution</strong></p><p>The nodes in the list are already linked, and hence the rotation basically means</p><ul><li>To close the linked list into the ring.</li><li>To break the ring after the new tail and just in front of the new head.</li></ul><p><img src="https://leetcode.com/problems/rotate-list/Figures/61/rotate.png" alt="rotate"></p><p>new_head = (len - k) % len</p><p>new_tail = (len - k) % (len - 1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">rotateRight</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// base cases</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// close the linked list into the ring</span></span><br><span class="line">        ListNode old_tail = head;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">for</span>(n = <span class="number">1</span>; old_tail.next != <span class="keyword">null</span>; n++)&#123;</span><br><span class="line">            old_tail = old_tail.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        old_tail.next = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// find new tail : (n - k % n - 1)th node</span></span><br><span class="line">        <span class="comment">// and new head : (n - k % n)th node</span></span><br><span class="line">        ListNode new_tail = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - k % n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            new_tail = new_tail.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode new_head = new_tail.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// break the ring</span></span><br><span class="line">        new_tail.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> new_head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Time Complexity O(n)</p><p>Space Complexity O(1)</p><h2 id="Leetcode-82-Remove-Duplicates-from-Sorted-List-II"><a href="#Leetcode-82-Remove-Duplicates-from-Sorted-List-II" class="headerlink" title="Leetcode 82 Remove Duplicates from Sorted List II"></a>Leetcode 82 Remove Duplicates from Sorted List II</h2><p>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only <em>distinct</em> numbers from the original list.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5</span><br><span class="line">Output: 1-&gt;2-&gt;5</span><br></pre></td></tr></table></figure><p><strong>Solution</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode current = head;</span><br><span class="line">        <span class="comment">// if current node is duplicated (same as head), skip it.</span></span><br><span class="line">        <span class="keyword">if</span> (head.val == head.next.val)&#123;</span><br><span class="line">            <span class="keyword">while</span> (current != <span class="keyword">null</span> &amp;&amp; current.val == head.val)&#123;</span><br><span class="line">                current = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> deleteDuplicates(current);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// else recurrsively call the deleteDuplicates() function</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            head.next = deleteDuplicates(head.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Time Complexity O(n)</p><p>Space Complexity O(n) </p><h2 id="Leetcode-725-Split-Linked-List-in-Parts"><a href="#Leetcode-725-Split-Linked-List-in-Parts" class="headerlink" title="Leetcode 725 Split Linked List in Parts"></a>Leetcode 725 Split Linked List in Parts</h2><p>Given a (singly) linked list with head node <code>root</code>, write a function to split the linked list into <code>k</code> consecutive linked list “parts”.</p><p>The length of each part should be as equal as possible: no two parts should have a size differing by more than 1. This may lead to some parts being null.</p><p>The parts should be in order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal parts occurring later.</p><p>Return a List of ListNode’s representing the linked list parts that are formed.</p><p>Examples 1-&gt;2-&gt;3-&gt;4, k = 5 // 5 equal parts [ [1], [2], [3], [4], null ]</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">root = [1, 2, 3], k = 5</span><br><span class="line">Output: [[1],[2],[3],[],[]]</span><br><span class="line">Explanation:</span><br><span class="line">The input and each element of the output are ListNodes, not arrays.</span><br><span class="line">For example, the input root has root.val = 1, root.next.val = 2, \root.next.next.val = 3, and root.next.next.next = null.</span><br><span class="line">The first element output[0] has output[0].val = 1, output[0].next = null.</span><br><span class="line">The last element output[4] is null, but it&apos;s string representation as a ListNode is [].</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">root = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3</span><br><span class="line">Output: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]</span><br><span class="line">Explanation:</span><br><span class="line">The input has been split into consecutive parts with size difference at most 1, and earlier parts are a larger size than the later parts.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><p>The length of <code>root</code> will be in the range <code>[0, 1000]</code>.</p><p>Each value of a node in the input will be an integer in the range <code>[0, 999]</code>.</p><p><code>k</code> will be an integer in the range <code>[1, 50]</code>.</p><p><strong>Solution</strong></p><p>The key of this problem is to find the <strong>tail</strong> of each partition, If there are N nodes in the linked list <code>root</code>, then there are N / k items in each part, plus the first N % k parts have an extra item. We can count N with a simple loop.Now for each part, we have calculated how many nodes that part will have: <code>width + (i &lt; remainder ? 1 : 0)</code> , so the <strong>tail</strong> of each partition should be <code>width + (i &lt; remainder ? 1 : 0) - 1</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode[] splitListToParts(ListNode root, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        ListNode cur = root;</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            N++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> width = N / k, rem = N % k;</span><br><span class="line"></span><br><span class="line">        ListNode[] ans = <span class="keyword">new</span> ListNode[k];</span><br><span class="line">        cur = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            ListNode head = cur;</span><br><span class="line">            <span class="comment">// find the tail of each partition</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; width + (i &lt; rem ? <span class="number">1</span> : <span class="number">0</span>) - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur != <span class="keyword">null</span>) cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// split the list</span></span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ListNode prev = cur;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">                prev.next = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// record the head</span></span><br><span class="line">            ans[i] = head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Time Complexity: <strong>O(N+k)</strong>, where N is the number of nodes in the given list. If k is large, it could still require creating many new empty lists.</p><p>Space Complexity: <strong>O(k)</strong>, the additional space used in writing the answer.</p><h2 id="Leetcode-369-Plus-One-Linked-List"><a href="#Leetcode-369-Plus-One-Linked-List" class="headerlink" title="Leetcode 369 Plus One Linked List"></a>Leetcode 369 Plus One Linked List</h2><p>Given a non-negative integer represented as <strong>non-empty</strong> a singly linked list of digits, plus one to the integer.</p><p>You may assume the integer do not contain any leading zero, except the number 0 itself.</p><p>The digits are stored such that the most significant digit is at the head of the list.</p><p><strong>Example :</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3]</span><br><span class="line">Output: [1,2,4]</span><br></pre></td></tr></table></figure><p><strong>Solution</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">plusOne</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        Stack&lt;ListNode&gt; s = <span class="keyword">new</span> Stack&lt;ListNode&gt;();</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            s.push(cur);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">1</span>;</span><br><span class="line">        ListNode temp = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!s.isEmpty() || carry == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s.isEmpty())&#123;</span><br><span class="line">                ListNode node = temp;</span><br><span class="line">                temp = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">                temp.next = node;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                temp = s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            temp.val = temp.val + carry;</span><br><span class="line">            carry = (temp.val &gt;= <span class="number">10</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            temp.val = (temp.val &gt;= <span class="number">10</span>) ? temp.val % <span class="number">10</span> : temp.val;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Time Complexity O(n)</p><p>Space Complexity O(n)</p><h2 id="Leetcode-1019-Next-Greater-Node-In-Linked-List"><a href="#Leetcode-1019-Next-Greater-Node-In-Linked-List" class="headerlink" title="Leetcode 1019 Next Greater Node In Linked List"></a>Leetcode 1019 Next Greater Node In Linked List</h2><p>We are given a linked list with <code>head</code> as the first node.  Let’s number the nodes in the list: <code>node_1, node_2, node_3, ...</code> etc.</p><p>Each node may have a <em>next larger</em> <strong>value</strong>: for <code>node_i</code>, <code>next_larger(node_i)</code> is the <code>node_j.val</code> such that <code>j &gt; i</code>, <code>node_j.val &gt; node_i.val</code>, and <code>j</code> is the smallest possible choice.  If such a <code>j</code> does not exist, the next larger value is <code>0</code>.</p><p>Return an array of integers <code>answer</code>, where <code>answer[i] = next_larger(node_{i+1})</code>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,1,5]</span><br><span class="line">Output: [5,5,0]</span><br></pre></td></tr></table></figure><p><strong>Solution</strong></p><p>We can use two stacks <strong>stack &amp; max</strong>: one stores the elements in reversed order and one stores the current maximum value.</p><p><strong>Two stack approach</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextLargerNodes(ListNode head) &#123;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;ListNode&gt; max = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> length = stack.size();</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            ListNode top = stack.pop();</span><br><span class="line">            <span class="keyword">while</span> (!max.isEmpty() &amp;&amp; max.peek().val &lt;= top.val)&#123;</span><br><span class="line">                max.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!max.isEmpty())&#123;</span><br><span class="line">                result[i] = max.peek().val;</span><br><span class="line">            &#125;</span><br><span class="line">            max.push(top);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> Time Complexity O(n)</p><p>Space Complexity O(n)</p><p><strong>Monotonous stack approach</strong></p><p>A monotone Stack/Queue is a data structure the elements from the front to the end is strictly either increasing or decreasing</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">index   v   Increasing queue        Decreasing queue</span><br><span class="line">1       5   [5]                     [5]</span><br><span class="line">2       3   [3] 3 kick out 5        [5, 3] #3-&gt;5</span><br><span class="line">3       1   [1] 1 kick out 3        [5, 3, 1] #1-&gt;3</span><br><span class="line">4       2   [1, 2] #2-&gt;1            [5, 3, 2] 2 kick out 1 #2-&gt;3</span><br><span class="line">5       4   [1, 2, 4] #4-&gt;2         [5,4] 4 kick out 2, 3 #4-&gt;2</span><br></pre></td></tr></table></figure><p>Monotone Stack/Queue is ususlly used to find <em>next/previous larger/ smaller node</em> problem. We can solve these kind of problem by maintaining a monotone stack (store the index instead of value)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextLargerNodes(ListNode head) &#123;</span><br><span class="line">        List &lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stack &lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            list.add(head.val);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = list.size();</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; list.get(i) &gt; list.get(stack.peek()))&#123;</span><br><span class="line">                result[stack.pop()] = list.get(i);</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Time Complexity O(n)</p><p>Space Compelxity O(n)</p><h2 id="Leetcode-708-Insert-into-a-Cyclic-Sorted-List"><a href="#Leetcode-708-Insert-into-a-Cyclic-Sorted-List" class="headerlink" title="Leetcode 708 Insert into a Cyclic Sorted List"></a>Leetcode 708 Insert into a Cyclic Sorted List</h2><p>Given a node from a cyclic linked list which is sorted in ascending order, write a function to insert a value into the list such that it remains a cyclic sorted list. The given node can be a reference to <em>any</em> single node in the list, and may not be necessarily the smallest value in the cyclic list.</p><p>If there are multiple suitable places for insertion, you may choose any place to insert the new value. After the insertion, the cyclic list should remain sorted.</p><p>If the list is empty (i.e., given node is <code>null</code>), you should create a new single cyclic list and return the reference to that single node. Otherwise, you should return the original given node.</p><p>The following example may help you understand the problem better:</p><p><img src="https://assets.leetcode.com/uploads/2019/01/19/example_1_before_65p.jpg" alt="img"></p><p>In the figure above, there is a cyclic sorted list of three elements. You are given a reference to the node with value 3, and we need to insert 2 into the list.</p><p><img src="https://assets.leetcode.com/uploads/2019/01/19/example_1_after_65p.jpg" alt="img"></p><p><strong>Solution</strong></p><p>There’re two possible situations: </p><p>(1) <strong>min(list) &lt;= insertVal &lt;= max(list)</strong> -&gt; insert between <strong>current</strong> and <strong>current.next</strong></p><p>(2) <strong>insertVal &gt; max(list) || insertVal &lt; min(list)</strong>  -&gt; insert after the maximum node</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">insert</span><span class="params">(Node head, <span class="keyword">int</span> insertVal)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// null situation</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            Node result = <span class="keyword">new</span> Node(insertVal, <span class="keyword">null</span>);</span><br><span class="line">            result.next = result;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Node cur = head;</span><br><span class="line">        Node max = cur;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (insertVal &gt;= cur.val &amp;&amp; insertVal &lt;= cur.next.val)&#123;</span><br><span class="line">                <span class="comment">// insert between cur and cur.next</span></span><br><span class="line">                Node insert = <span class="keyword">new</span> Node(insertVal,cur.next); </span><br><span class="line">                cur.next = insert;</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (cur.val &gt;= max.val)&#123;</span><br><span class="line">                max = cur;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// reaches the end of the list</span></span><br><span class="line">            <span class="keyword">if</span> (cur.next == head)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// insert after the maximum node</span></span><br><span class="line">        Node insert = <span class="keyword">new</span> Node(insertVal, max.next);</span><br><span class="line">        max.next = insert;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Time Complexity O(n)</p><p>Space Compelxity O(1)</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode-25-Reverse-Nodes-in-k-Group&quot;&gt;&lt;a href=&quot;#Leetcode-25-Reverse-Nodes-in-k-Group&quot; class=&quot;headerlink&quot; title=&quot;Leetcode 25 Reverse Nodes in k-Group&quot;&gt;&lt;/a&gt;Leetcode 25 Reverse Nodes in k-Group&lt;/h2&gt;&lt;p&gt;Given a linked list, reverse the nodes of a linked list &lt;em&gt;k&lt;/em&gt; at a time and return its modified list.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;k&lt;/em&gt; is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of &lt;em&gt;k&lt;/em&gt; then left-out nodes in the end should remain as it is.&lt;/p&gt;
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode-Medium" scheme="http://yoursite.com/tags/Leetcode-Medium/"/>
    
      <category term="LinkedList" scheme="http://yoursite.com/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode -- Linked List (Part 2)</title>
    <link href="http://yoursite.com/2019/05/25/LinkedList2/"/>
    <id>http://yoursite.com/2019/05/25/LinkedList2/</id>
    <published>2019-05-25T11:49:55.000Z</published>
    <updated>2019-05-28T14:46:22.719Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-148-Sort-List"><a href="#Leetcode-148-Sort-List" class="headerlink" title="Leetcode 148 Sort List"></a>Leetcode 148 Sort List</h2><p>Sort a linked list.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 4-&gt;2-&gt;1-&gt;3</span><br><span class="line">Output: 1-&gt;2-&gt;3-&gt;4</span><br></pre></td></tr></table></figure><p><strong>Solution</strong></p><p>We can sort a list using merge sort approach. The key is to find the middle of the list (remember the fast-slow pointer technique?). <a id="more"></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">      <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// step 1. cut the list to two halves</span></span><br><span class="line">    ListNode prev = <span class="keyword">null</span>, slow = head, fast = head;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">      prev = slow;</span><br><span class="line">      slow = slow.next;</span><br><span class="line">      fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    prev.next = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// step 2. sort each half</span></span><br><span class="line">    ListNode l1 = sortList(head);</span><br><span class="line">    ListNode l2 = sortList(slow);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// step 3. merge l1 and l2</span></span><br><span class="line">    <span class="keyword">return</span> merge(l1, l2);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function">ListNode <span class="title">merge</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    ListNode l = <span class="keyword">new</span> ListNode(<span class="number">0</span>), p = l;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// merge two lists</span></span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">        p.next = l1;</span><br><span class="line">        l1 = l1.next;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        p.next = l2;</span><br><span class="line">        l2 = l2.next;</span><br><span class="line">      &#125;</span><br><span class="line">      p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// if one list reaches the end, we can append the other to the end of it</span></span><br><span class="line">    <span class="keyword">if</span> (l1 != <span class="keyword">null</span>)</span><br><span class="line">      p.next = l1;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (l2 != <span class="keyword">null</span>)</span><br><span class="line">      p.next = l2;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> l.next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Time Complexity O(logn)</p><p>Space Complexity O(n) -&gt; we call recurrsive function n times </p><h2 id="Leetcode-86-Partition-List"><a href="#Leetcode-86-Partition-List" class="headerlink" title="Leetcode 86 Partition List"></a>Leetcode 86 Partition List</h2><p>Given a linked list and a value <em>x</em>, partition it such that all nodes less than <em>x</em> come before nodes greater than or equal to <em>x</em>.</p><p>You should preserve the original relative order of the nodes in each of the two partitions.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3</span><br><span class="line">Output: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</span><br></pre></td></tr></table></figure><p><strong>Solutionx</strong></p><p>We can divide the list into two parts – left parts contains all the elements that is less than <em>x</em> while the other one contains all the elements that is greater than <em>x</em>. The left part’s head is <em>left_head</em> while the right part’s head is <em>right_head</em>.  The following approach shows how to solve this problem in details.</p><p>(1) Traverse the whole linked list, if <em>current.val &lt; x</em> then add it to the left part. If <em>current.val &gt;= x</em> add it to the right part.</p><p>(2) Concat two parts.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">partition</span><span class="params">(ListNode head, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ListNode left = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode left_head = left;</span><br><span class="line">        ListNode right = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode right_head = right;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (head.val &lt; x)&#123;</span><br><span class="line">                left.next = head;</span><br><span class="line">                left = left.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                right.next = head;</span><br><span class="line">                right = right.next;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        left.next = right_head.next;</span><br><span class="line">     </span><br><span class="line">        right.next = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> left_head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Time Complexity O(n)</p><p>Space Complexity O(1)</p><h2 id="Leetcode-138-Copy-List-with-Random-Pointer"><a href="#Leetcode-138-Copy-List-with-Random-Pointer" class="headerlink" title="Leetcode 138 Copy List with Random Pointer"></a>Leetcode 138 Copy List with Random Pointer</h2><p>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.</p><p>Return a <a href="https://en.wikipedia.org/wiki/Object_copying#Deep_copy" target="_blank" rel="noopener"><strong>deep copy</strong></a> of the list.</p><p><strong>Example 1:</strong></p><p><strong><img src="https://discuss.leetcode.com/uploads/files/1470150906153-2yxeznm.png" alt="img"></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">&#123;&quot;$id&quot;:&quot;1&quot;,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;2&quot;,&quot;next&quot;:null,&quot;random&quot;:&#123;&quot;$ref&quot;:&quot;2&quot;&#125;,&quot;val&quot;:2&#125;,&quot;random&quot;:&#123;&quot;$ref&quot;:&quot;2&quot;&#125;,&quot;val&quot;:1&#125;</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">Node 1&apos;s value is 1, both of its next and random pointer points to Node 2.</span><br><span class="line">Node 2&apos;s value is 2, its next pointer points to null and its random pointer points to itself.</span><br></pre></td></tr></table></figure><p><strong>Solution</strong></p><ol><li><p>Traverse the original list and clone the nodes as you go and place the cloned copy next to its original node. This new linked list is essentially a interweaving of original and cloned nodes.</p><p><img src="https://leetcode.com/problems/copy-list-with-random-pointer/Figures/138/138_Copy_List_Random_8_1.png" alt="img"></p><p><img src="https://leetcode.com/problems/copy-list-with-random-pointer/Figures/138/138_Copy_List_Random_8_2.png" alt="img"></p><p>As you can see we just use the value of original node to create the cloned copy. The <code>next</code>pointer is used to create the weaving. Note that this operation ends up modifying the original linked list.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cloned_node.next = original_node.next</span><br><span class="line">original_node.next = cloned_node</span><br></pre></td></tr></table></figure></li><li><p>Iterate the list having both the new and old nodes intertwined with each other and use the original nodes’ random pointers to assign references to random pointers for cloned nodes. For eg. If <code>B</code> has a random pointer to <code>A</code>, this means <code>B&#39;</code> has a random pointer to <code>A&#39;</code>.</p><p><img src="https://leetcode.com/problems/copy-list-with-random-pointer/Figures/138/138_Copy_List_Random_9_1.png" alt="img"></p></li><li><p>Now that the <code>random</code> pointers are assigned to the correct node, the <code>next</code> pointers need to be correctly assigned to unweave the current linked list and get back the original list and the cloned list.</p><p><img src="https://leetcode.com/problems/copy-list-with-random-pointer/Figures/138/138_Copy_List_Random_10.png" alt="img"></p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// tweak the list</span></span><br><span class="line">        Node current = head;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="keyword">null</span>)&#123;</span><br><span class="line">            current.next = <span class="keyword">new</span> Node(current.val, current.next, current.random);</span><br><span class="line">            current = current.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Node copy_head = head.next;</span><br><span class="line">        Node copy_current;</span><br><span class="line">        current = head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// assign random field to cloned nodes</span></span><br><span class="line">        <span class="keyword">while</span> (current != <span class="keyword">null</span>)&#123;</span><br><span class="line">            copy_current = current.next;</span><br><span class="line">            copy_current.random = (current.random == <span class="keyword">null</span>) ? <span class="keyword">null</span> : current.random.next;</span><br><span class="line">            current = current.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        current = head;</span><br><span class="line">        copy_current = copy_head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// split the original list and the copied one</span></span><br><span class="line">        <span class="keyword">while</span> (current != <span class="keyword">null</span>)&#123;</span><br><span class="line">            current.next = current.next.next;</span><br><span class="line">            <span class="keyword">if</span> (copy_current.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">                copy_current.next = copy_current.next.next;</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.next;</span><br><span class="line">            copy_current = copy_current.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> copy_head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Time Complexity O(n)</p><p>Space Complexity O(1)</p><h2 id="Leetcode-24-Swap-Nodes-in-Pairs"><a href="#Leetcode-24-Swap-Nodes-in-Pairs" class="headerlink" title="Leetcode 24 Swap Nodes in Pairs"></a>Leetcode 24 Swap Nodes in Pairs</h2><p>Given a linked list, swap every two adjacent nodes and return its head.</p><p>You may <strong>not</strong> modify the values in the list’s nodes, only nodes itself may be changed.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure><p><strong>Solution</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode result = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        result.next = head;</span><br><span class="line">        ListNode prev = result;</span><br><span class="line">        ListNode current = head;</span><br><span class="line">        ListNode next = current.next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(current != <span class="keyword">null</span> &amp;&amp; next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            current.next = next.next;</span><br><span class="line">            next.next = current;</span><br><span class="line">            prev.next = next;</span><br><span class="line">            current = current.next;</span><br><span class="line">            <span class="keyword">if</span> (current == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = next.next;</span><br><span class="line">            next = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Time Complexity O(n)</p><p>Space Complexity O(1)</p><h2 id="Leetcode-23-Merge-k-Sorted-Lists"><a href="#Leetcode-23-Merge-k-Sorted-Lists" class="headerlink" title="Leetcode 23 Merge k Sorted Lists"></a>Leetcode 23 Merge k Sorted Lists</h2><p>Merge <em>k</em> sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure><p><strong>Solution</strong></p><p>The most intuitive way to solve this problem is to merge 2 lists at a time. (Recall Leetcode 21 Merge two sorted lists) The time complexity for this algorithm is O(kN)  (N is the total number of items in the lists) for the time complexity to merge two lists is O(m + n). However, using the idea of merge sort, we can reduce the time complexity to O(Nlogk).</p><p><strong>We don’t need to traverse most nodes many times repeatedly</strong></p><ul><li>Pair up k lists and merge each pair.</li><li>After the first pairing, k lists are merged into k/2 lists with average 2N/k length, then k/4, k/8 and so on.</li><li>Repeat this procedure until we get the final sorted linked list.</li></ul><p>Thus, we’ll traverse almost N nodes per pairing and merging, and repeat this procedure about log2k times.</p><p><strong>Iterative in-place merge sort</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> interval = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (interval &lt; length)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - interval; i = i + <span class="number">2</span> * interval)&#123;</span><br><span class="line">lists[i] = merge2Lists(lists[i], lists[i + interval]);</span><br><span class="line">&#125;</span><br><span class="line">interval *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://leetcode.com/problems/merge-k-sorted-lists/Figures/23/23_divide_and_conquer_new.png" alt="Divide_and_Conquer">{align = “center”}</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = lists.length;</span><br><span class="line">        <span class="keyword">if</span> (lists == <span class="keyword">null</span> || length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> merge2Lists(lists[<span class="number">0</span>], <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> interval = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (interval &lt; length)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - interval; i = i + <span class="number">2</span> * interval)&#123;</span><br><span class="line">                lists[i] = merge2Lists(lists[i], lists[i + interval]);</span><br><span class="line">            &#125;</span><br><span class="line">            interval *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">merge2Lists</span><span class="params">(ListNode l1, ListNode l2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (l2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode result = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (l1.val &lt;= l2.val)&#123;</span><br><span class="line">                head.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                head.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (l1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            head.next = l1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            head.next = l2;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Time Complexity O(Nlogk)</p><p>Space Complexity O(1) -&gt; inplace merge sort</p><h2 id="Leetcode-328-Odd-Even-Linked-List"><a href="#Leetcode-328-Odd-Even-Linked-List" class="headerlink" title="Leetcode 328 Odd Even Linked List"></a>Leetcode 328 Odd Even Linked List</h2><p>Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.</p><p>You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">Output: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL</span><br></pre></td></tr></table></figure><p><strong>Solution</strong></p><p>We can divide the list into two parts then append the even list to the end of the odd list.</p><p>An illustration of our algorithm is following:</p><p><img src="https://leetcode.com/problems/odd-even-linked-list/Figures/328_Odd_Even.svg" alt="Illustration of odd even linked list"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">oddEvenList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode odd_head = head;</span><br><span class="line">        ListNode even_head = head.next;</span><br><span class="line">        ListNode odd = odd_head;</span><br><span class="line">        ListNode even = even_head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (even != <span class="keyword">null</span> &amp;&amp; even.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            odd.next = even.next;</span><br><span class="line">            even.next = even.next.next;</span><br><span class="line">            odd = odd.next;</span><br><span class="line">            even = even.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        odd.next = even_head;</span><br><span class="line">        <span class="keyword">return</span> odd_head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Time Complexity O(n)</p><p>Space Complexity O(1)</p><h2 id="Leetcode-147-Insertion-Sort-List"><a href="#Leetcode-147-Insertion-Sort-List" class="headerlink" title="Leetcode 147 Insertion Sort List"></a>Leetcode 147 Insertion Sort List</h2><p>Sort a linked list using insertion sort.</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif" alt="img"></p><p><strong>Solution</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">insertionSortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode current = head;</span><br><span class="line">        ListNode sorted_head = <span class="keyword">new</span> ListNode(Integer.MIN_VALUE);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(current != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode next = current.next;</span><br><span class="line">            current.next = <span class="keyword">null</span>;</span><br><span class="line">            insertNode(sorted_head, current);</span><br><span class="line">            current = next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sorted_head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertNode</span><span class="params">(ListNode head, ListNode node)</span></span>&#123;      </span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        ListNode prev = cur;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span> &amp;&amp; cur.val &lt; node.val)&#123;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">            node.next = prev.next;</span><br><span class="line">            prev.next = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Time Complexity O(n^2)</p><p>Space Complexity O(n)</p><h2 id="Leetcode-142-Linked-List-Cycle-II"><a href="#Leetcode-142-Linked-List-Cycle-II" class="headerlink" title="Leetcode 142 Linked List Cycle II"></a>Leetcode 142 Linked List Cycle II</h2><p>Given a linked list, return the node where the cycle begins. If there is no cycle, return <code>null</code>.</p><p>To represent a cycle in the given linked list, we use an integer <code>pos</code> which represents the position (0-indexed) in the linked list where tail connects to. If <code>pos</code> is <code>-1</code>, then there is no cycle in the linked list.</p><p><strong>Note:</strong> Do not modify the linked list.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [3,2,0,-4], pos = 1</span><br><span class="line">Output: tail connects to node index 1</span><br><span class="line">Explanation: There is a cycle in the linked list, where tail connects to the second node.</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p><p><strong>Solution</strong></p><p>This problem can be sovled in two steps. First, we need to find if there exists a cycle or not by using fast and slow pointer technique.(Recall <strong>Linked List Cycle 1</strong> in Part 1) Then, we set slow to the head of the list and fast to the intersection node. We move slow and fast 1 step at a time, then they will finally meet at the entrance of the cycle. The proof is shown below:</p><p><img src="https://leetcode.com/problems/linked-list-cycle-ii/Figures/142/diagram.png" alt="Phase 2 diagram"></p><p>When <strong>fast</strong> meets <strong>slow</strong>, we know that <strong>fast</strong> travels twice as many nodes as <strong>slow</strong>.</p><p>That is <strong>2 * (F + a) = F + a + b + a</strong></p><p>Then we will have <strong>F = b</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        <span class="keyword">boolean</span> hasCycle = <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// find if there's a cycle</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow)&#123;</span><br><span class="line">                hasCycle = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// find the entrance of the cycle</span></span><br><span class="line">        <span class="keyword">if</span> (hasCycle == <span class="keyword">true</span>)&#123;</span><br><span class="line">            slow = head;</span><br><span class="line">            <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">                slow = slow.next;</span><br><span class="line">                fast = fast.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> slow;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Time Complexity O(n)</p><p>Space Complexity O(1)</p><h2 id="Leetcode-19-Remove-Nth-Node-From-End-of-List"><a href="#Leetcode-19-Remove-Nth-Node-From-End-of-List" class="headerlink" title="Leetcode 19 Remove Nth Node From End of List"></a>Leetcode 19 Remove Nth Node From End of List</h2><p>Given a linked list, remove the <em>n</em>-th node from the end of list and return its head.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.</span><br><span class="line"></span><br><span class="line">After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><p>Given <em>n</em> will always be valid.</p><p><strong>What if n is arbitrary ?</strong></p><p><strong>Solution</strong></p><p>Using fast-slow-pointer trick, <strong>fast</strong> move n steps first, then both <strong>fast</strong> and <strong>slow</strong> starts moving 1 step per time.  Once <strong>fast</strong> reaches the end, <strong>slow</strong> points to the node that needs to be deleted. </p><p>Here’re two cases:</p><p>(1) <strong>slow</strong> is not pointing to the last node, we can delete it in O(1). (Recall <strong>Delete Node in a Linked List </strong> in Part 1)</p><p>(2)  <strong>slow</strong> is pointing to the last node. Time complexity increases to O(n).</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode next = slow.next;</span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode current = head;</span><br><span class="line">            <span class="keyword">while</span> (current.next != slow)&#123;</span><br><span class="line">                current = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">            current.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            slow.val = next.val;</span><br><span class="line">            slow.next = next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Time Complexity O(n)</p><p>Space Complexity O(1)</p><h2 id="Leetcode-445-Add-Two-Numbers-II"><a href="#Leetcode-445-Add-Two-Numbers-II" class="headerlink" title="Leetcode 445 Add Two Numbers II"></a>Leetcode 445 Add Two Numbers II</h2><p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p><p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><p><strong>Follow up:</strong><br>What if you cannot modify the input lists? In other words, reversing the lists is not allowed.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">Output: 7 -&gt; 8 -&gt; 0 -&gt; 7</span><br></pre></td></tr></table></figure><p><strong>Solution</strong></p><p>An intuitive solution is to reverse the list and transform the problem to <strong>Add Two Numbers</strong>. In this way, we must modify the original list. By using a stack, we can ‘reverse’ the list, without modifying the original list.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        Stack&lt;ListNode&gt; s1 = <span class="keyword">new</span> Stack&lt;ListNode&gt;();</span><br><span class="line">        Stack&lt;ListNode&gt; s2 = <span class="keyword">new</span> Stack&lt;ListNode&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            s1.push(l1);</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            s2.push(l2);</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!s1.isEmpty() || !s2.isEmpty() || carry == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s1.isEmpty())&#123;</span><br><span class="line">                ListNode node = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">                node.next = l1;</span><br><span class="line">                l1 = node;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                l1 = s1.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            l2 = s2.isEmpty() ? <span class="keyword">new</span> ListNode(<span class="number">0</span>) : s2.pop();</span><br><span class="line">            l1.val = l1.val + l2.val + carry;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (l1.val &gt;= <span class="number">10</span>)&#123;</span><br><span class="line">                l1.val %= <span class="number">10</span>;</span><br><span class="line">                carry = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                carry = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Time Complexity O(m + n)</p><p>Space Complexity O(m + n)</p><h2 id="Leetcode-143-Reorder-List"><a href="#Leetcode-143-Reorder-List" class="headerlink" title="Leetcode 143 Reorder List"></a>Leetcode 143 Reorder List</h2><p>Given a singly linked list <em>L</em>: <em>L</em>0→<em>L</em>1→…→<em>Ln</em>-1→<em>L</em>n,<br>reorder it to: <em>L</em>0→<em>Ln</em>→<em>L</em>1→<em>Ln</em>-1→<em>L</em>2→<em>Ln</em>-2→…</p><p>You may <strong>not</strong> modify the values in the list’s nodes, only nodes itself may be changed.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Given 1-&gt;2-&gt;3-&gt;4, reorder it to 1-&gt;4-&gt;2-&gt;3.</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Given 1-&gt;2-&gt;3-&gt;4-&gt;5, reorder it to 1-&gt;5-&gt;2-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure><p><strong>Solution</strong></p><p>If we look carefully at the reordered list, we’ll find it consists two parts: <strong>1,3,5</strong> and <strong>2,4</strong>. The reordered list can be  created by merging these two lists.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//split list into two halves</span></span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            prev = slow;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        prev.next = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//reverse the second part</span></span><br><span class="line">        slow = reverseList(slow);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//merge two lists</span></span><br><span class="line">        head =  merge(head, slow);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">        ListNode current = head;</span><br><span class="line">            <span class="keyword">while</span>(current != <span class="keyword">null</span>)&#123;</span><br><span class="line">                ListNode next = current.next;</span><br><span class="line">                current.next = prev;</span><br><span class="line">                prev = current;</span><br><span class="line">                current = next;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">merge</span><span class="params">(ListNode head_1, ListNode head_2)</span></span>&#123;</span><br><span class="line">        ListNode result = head_1;</span><br><span class="line">        <span class="keyword">while</span>(head_1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode next_1 = head_1.next;</span><br><span class="line">            ListNode next_2 = head_2.next;</span><br><span class="line">            head_1.next = head_2;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (next_1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            head_2.next = next_1;</span><br><span class="line">            head_1 = next_1;</span><br><span class="line">            head_2 = next_2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Time Complexity O(n)</p><p>Space Complexity O(1)</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode-148-Sort-List&quot;&gt;&lt;a href=&quot;#Leetcode-148-Sort-List&quot; class=&quot;headerlink&quot; title=&quot;Leetcode 148 Sort List&quot;&gt;&lt;/a&gt;Leetcode 148 Sort List&lt;/h2&gt;&lt;p&gt;Sort a linked list.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example 1:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: 4-&amp;gt;2-&amp;gt;1-&amp;gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;Solution&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;We can sort a list using merge sort approach. The key is to find the middle of the list (remember the fast-slow pointer technique?).
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="Leetcode-Medium" scheme="http://yoursite.com/tags/Leetcode-Medium/"/>
    
      <category term="LinkedList" scheme="http://yoursite.com/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode -- Linked List (Part 1)</title>
    <link href="http://yoursite.com/2019/05/19/LinkedList/"/>
    <id>http://yoursite.com/2019/05/19/LinkedList/</id>
    <published>2019-05-19T09:47:34.000Z</published>
    <updated>2019-05-24T14:03:27.960Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-876-Middle-of-the-Linked-List"><a href="#Leetcode-876-Middle-of-the-Linked-List" class="headerlink" title="Leetcode 876 Middle of the Linked List"></a>Leetcode 876 Middle of the Linked List</h2><p>Given a non-empty, singly linked list with head node <code>head</code>, return a middle node of linked list.</p><p>If there are two middle nodes, return the second middle node.<a id="more"></a></p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,2,3,4,5]</span><br><span class="line">Output: Node 3 from this list (Serialization: [3,4,5])</span><br><span class="line">The returned node has value 3.  (The judge&apos;s serialization of this node is [3,4,5]).</span><br><span class="line">Note that we returned a ListNode object ans, such that:</span><br><span class="line">ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, and ans.next.next.next = NULL.</span><br></pre></td></tr></table></figure><p><strong>Solution</strong></p><p>We can define a fast pointer that moves 2 steps per iteration and a slow pointer that moves 1 steps per iteration. Then, when the fast pointer reaches the end of the Linked-List, the slow pointer will stop at the middle of the Linked List. </p><p>Since we only traverse the list once, the time complexity of this solution is O(n). We did’t use any extra space so the space complexity of this solution is O(1).</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">middleNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (fast.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Leetcode-206-Reverse-Linked-List"><a href="#Leetcode-206-Reverse-Linked-List" class="headerlink" title="Leetcode 206 Reverse Linked List"></a>Leetcode 206 Reverse Linked List</h2><p>Reverse a singly linked list.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">Output: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure><p><strong>Solution</strong></p><p>Linked List problems usually has two solutions – Iterative or recursive. </p><p>Let’s assume that every elements before 3 has been reversed, then we will have a list like this:</p><p>1 <- 2 3 -> 4 -&gt; 5 </-></p><p>Now we need to set <strong>3.next = 2</strong> witch requires 2 pointers. However, the list will be disconnected by this operation so we need to use another pointer to store node 4.  By using these three pointers, we’re able to solve this problem in either iterative or recursive way. </p><p>(Recursive Approach)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode tail = reverseList(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> tail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Time Complexity O(n)</p><p>Space Complexity O(n) -&gt; Extra space from implicit stack space due to recursion. Recursion could go up to <em>n</em> levels deep.</p><p>(Iterative Approach)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        ListNode previous = <span class="keyword">null</span>;</span><br><span class="line">        ListNode current = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (current != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode next = current.next;</span><br><span class="line">            current.next = previous;</span><br><span class="line">            previous = current;</span><br><span class="line">            current = next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> previous;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Time Complexity O(n)</p><p>Space Complexity O(1)</p><h2 id="Leetcode-237-Delete-Node-in-a-Linked-List"><a href="#Leetcode-237-Delete-Node-in-a-Linked-List" class="headerlink" title="Leetcode 237 Delete Node in a Linked List"></a>Leetcode 237 Delete Node in a Linked List</h2><p>Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.</p><p>Given linked list – head = [4,5,1,9], which looks like following:</p><p><img src="https://assets.leetcode.com/uploads/2018/12/28/237_example.png" alt="img"></p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [4,5,1,9], node = 5</span><br><span class="line">Output: [4,1,9]</span><br><span class="line">Explanation: You are given the second node with value 5, the linked list should become 4 -&gt; 1 -&gt; 9 after calling your function.</span><br></pre></td></tr></table></figure><p><strong>Note:</strong></p><ul><li>The linked list will have at least two elements.</li><li>All of the nodes’ values will be unique.</li><li>The given node will not be the tail and it will always be a valid node of the linked list. </li><li>Do not return anything from your function.</li></ul><p><strong>Solution</strong></p><p>Given only the node that needs to be deleted, we’re not able to delete it in a normal way (we don’t know the previous node). Instead, we can copy the next node and delete it for we can easily get next node by the <em>next</em> field.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">        node.val = node.next.val;</span><br><span class="line">        node.next = node.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Time Complexity O(1)</p><p>Space Complexity O(1)</p><h2 id="Leetcode-21-Merge-Two-Sorted-Lists"><a href="#Leetcode-21-Merge-Two-Sorted-Lists" class="headerlink" title="Leetcode 21 Merge Two Sorted Lists"></a>Leetcode 21 Merge Two Sorted Lists</h2><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure><p><strong>Solution</strong></p><p>The process should be like this:</p><p>(1) Create a head node <em>head</em></p><p>(2) Select min(l1, l2) as next node</p><p>(3) Set <em>selected_pointer</em> = <em>selected_pointer. next</em> until it reaches the end.</p><p>(Iterative Approach)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode current = head;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (l1.val &lt;= l2.val)&#123;</span><br><span class="line">                current.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                current.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            current = current.next;</span><br><span class="line">        &#125;</span><br><span class="line">        current.next = (l1 == <span class="keyword">null</span>) ? l2 : l1;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Time Complexity O(m + n)</p><p>Space Complexity O(1)</p><p>(Recursive Approach)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l1.val &lt;= l2.val)&#123;</span><br><span class="line">            l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Time Complexity O(m + n)</p><p>Space Complexity O(m + n)</p><h2 id="Leetcode-83-Remove-Duplicates-from-Sorted-List"><a href="#Leetcode-83-Remove-Duplicates-from-Sorted-List" class="headerlink" title="Leetcode 83 Remove Duplicates from Sorted List"></a>Leetcode 83 Remove Duplicates from Sorted List</h2><p>Given a sorted linked list, delete all duplicates such that each element appear only <em>once</em>.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;1-&gt;2</span><br><span class="line">Output: 1-&gt;2</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;1-&gt;2-&gt;3-&gt;3</span><br><span class="line">Output: 1-&gt;2-&gt;3</span><br></pre></td></tr></table></figure><p><strong>Solution</strong></p><p>The basic idea for solving this problem is to ‘skip’ the duplicated element by comparing itself and the node after it. if <em>current == current.next</em> , we skip this element. This can be done in a recursive way</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (head.next != <span class="keyword">null</span> &amp;&amp; head.val == head.next.val)&#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        head.next = deleteDuplicates(head.next);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Time Complexity O(n)</p><p>Space Complexity O(n)</p><h2 id="Leetcode-141-Linked-List-Cycle"><a href="#Leetcode-141-Linked-List-Cycle" class="headerlink" title="Leetcode 141 Linked List Cycle"></a>Leetcode 141 Linked List Cycle</h2><p>Given a linked list, determine if it has a cycle in it.</p><p>To represent a cycle in the given linked list, we use an integer <code>pos</code>which represents the position (0-indexed) in the linked list where tail connects to. If <code>pos</code> is <code>-1</code>, then there is no cycle in the linked list.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: head = [3,2,0,-4], pos = 1</span><br><span class="line">Output: true</span><br><span class="line">Explanation: There is a cycle in the linked list, where tail connects to the second node.</span><br></pre></td></tr></table></figure><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p><p><strong>Solution</strong></p><p>We usetwo pointers at <strong>different speed</strong> - a slow pointer and a fast pointer. The slow pointer moves one step at a time while the fast pointer moves two steps at a time.</p><p>If there is no cycle in the list, the fast pointer will eventually reach the end and we can return false in this case. Otherwise, the slow pointer will eventuall meets the fast pointer.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode slow = head.next;</span><br><span class="line">        ListNode fast = head.next.next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Time Complexity: O(n)</p><p>Space Complexity: O(1)</p><h2 id="Leetcode-234-Palindrome-Linked-List"><a href="#Leetcode-234-Palindrome-Linked-List" class="headerlink" title="Leetcode 234 Palindrome Linked List"></a>Leetcode 234 Palindrome Linked List</h2><p>Given a singly linked list, determine if it is a palindrome.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;2-&gt;1</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Solution</strong></p><p>The most straight forward way is to use a stack to reverse the whole Likend List or half of it to check if the output is the same. Space complexity for this solution is O(n). If we use two pointer method to find the middle of the list and then reverse the second part of the list, we can reduce space complexity to O(1). However, in this way, the original structure of linked list is broken.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (fast != <span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        slow = swap(slow);</span><br><span class="line">        fast = head;</span><br><span class="line">        <span class="keyword">while</span> (slow != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (fast.val != slow.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">swap</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode next = head.next;</span><br><span class="line">            head.next = prev;</span><br><span class="line">            prev = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Time Complexity O(n)</p><p>Space Complexity O(1)</p><h2 id="Leetcode-203-Remove-Linked-List-Elements"><a href="#Leetcode-203-Remove-Linked-List-Elements" class="headerlink" title="Leetcode 203 Remove Linked List Elements"></a>Leetcode 203 Remove Linked List Elements</h2><p>Remove all elements from a linked list of integers that have value <strong>val</strong>.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:  1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6</span><br><span class="line">Output: 1-&gt;2-&gt;3-&gt;4-&gt;5</span><br></pre></td></tr></table></figure><p><strong>Solution</strong></p><p>The removed element may appear in two places in the linked list (at the end of the list or not). Whne the element is in the list, time complexity is O(1) and space complexity is O(1). However, when the element appears at the end of list, the time complexity will increase to O(n). Because we can’t just set the last element to <em>null</em> , we need to find the previous node and set <em>prev.next = null</em>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        head.next = removeElements(head.next, val);</span><br><span class="line">        <span class="keyword">return</span> (head.val == val) ? head.next : head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Time Complexity O(n)</p><p>Space Complexity O(1)</p><h2 id="Leetcode-160-Intersection-of-Two-Linked-Lists"><a href="#Leetcode-160-Intersection-of-Two-Linked-Lists" class="headerlink" title="Leetcode 160 Intersection of Two Linked Lists"></a>Leetcode 160 Intersection of Two Linked Lists</h2><p>Write a program to find the node at which the intersection of two singly linked lists begins.</p><p>For example, the following two linked lists:</p><p><img src="https://assets.leetcode.com/uploads/2018/12/13/160_statement.png" alt="img"></p><p>begin to intersect at node c1.</p><p><strong>Example 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3</span><br><span class="line">Output: Reference of the node with value = 8</span><br><span class="line">Input Explanation: The intersected node&apos;s value is 8 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,0,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.</span><br></pre></td></tr></table></figure><p><strong>Notes:</strong></p><ul><li>If the two linked lists have no intersection at all, return <code>null</code>.</li><li>The linked lists must retain their original structure after the function returns.</li><li>You may assume there are no cycles anywhere in the entire linked structure.</li><li>Your code should preferably run in O(n) time and use only O(1) memory.</li></ul><p><strong>Solution</strong></p><p>If we traverse listA and for each node in listA, we traverse listB to see if it’s in listB as well. This BF approach has a time complexity of O(mn) and space complexity of O(1). We can improve this algorithm by using a hashset that records the nodes in listA and traverse listB to see if a node is in the hashset. This approach has a time complexity of O(m + n) and a space complexity of O(n). </p><p>If we can make modification to the original list, we can make it TC O(n + m), SC O(1) by reversing both lists iteratively. Can we do it without changing the structure of the lists? The answer is yes. We can use two pointers pA and pB initialzied at the head of A and B and traverse through the lists. When pA reaches the end of list, then redirect it to the head of B and viceversa. If at any point that pA meets pB, then pA is the intersection node.</p><p><strong>HashSet approach</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        HashSet&lt;ListNode&gt; set = <span class="keyword">new</span> HashSet&lt;ListNode&gt;();</span><br><span class="line">        <span class="keyword">while</span> (headA != <span class="keyword">null</span>)&#123;</span><br><span class="line">            set.add(headA);</span><br><span class="line">            headA = headA.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (headB != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (set.contains(headB))&#123;</span><br><span class="line">                <span class="keyword">return</span> headB;</span><br><span class="line">            &#125;</span><br><span class="line">            headB = headB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Time Complexity O(m + n)</p><p>Space Complexity O(n)</p><p><strong>Two pointer approach</strong></p><p>Note : If pA and pB  has now  intersaction, they will finally meet at the end of the  list which is null.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode pA = headA;</span><br><span class="line">        ListNode pB = headB;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (pA != pB)&#123;</span><br><span class="line">            pA = (pA == <span class="keyword">null</span>) ? headB : pA.next;</span><br><span class="line">            pB = (pB == <span class="keyword">null</span>) ? headA : pB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> pA;</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Time Complexity O(m + n)</p><p>Space Complexity O(1)</p><h2 id="Leetcode-2-Add-Two-Numbers"><a href="#Leetcode-2-Add-Two-Numbers" class="headerlink" title="Leetcode 2 Add Two Numbers"></a>Leetcode 2 Add Two Numbers</h2><p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong> and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p><p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">Output: 7 -&gt; 0 -&gt; 8</span><br><span class="line">Explanation: 342 + 465 = 807.</span><br></pre></td></tr></table></figure><p><strong>Solution</strong></p><p>We can traverse both list and edd each corresponding element (set <em>l1.val = l1.val + l2.val + carry</em>)</p><p>There’re two cases where we need to fill in zeros:</p><p>(1) One list reaches the end while the other doesn’t</p><p>(2) Carry equals to one and both list reaches the end</p><p>The <em>while</em> loop won’t break until : both listA and listB reaches the end and carry is not equals to 1.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        ListNode head = l1;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span> || l2 != <span class="keyword">null</span> || carry == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// calculate current val</span></span><br><span class="line">            l1.val = l1.val + l2.val + carry;</span><br><span class="line">            <span class="keyword">if</span> (l1.val &gt;= <span class="number">10</span>)&#123;</span><br><span class="line">                l1.val %= <span class="number">10</span>;</span><br><span class="line">                carry = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                carry = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// fill in zeros when one list reaches the end and the other doesn't or carry = 1</span></span><br><span class="line">            <span class="keyword">if</span> (carry == <span class="number">1</span> || (l1.next == <span class="keyword">null</span> &amp;&amp; l2.next != <span class="keyword">null</span>) || (l1.next != <span class="keyword">null</span> &amp;&amp; l2.next == <span class="keyword">null</span>))&#123;</span><br><span class="line">                l1.next = (l1.next == <span class="keyword">null</span>) ? <span class="keyword">new</span> ListNode(<span class="number">0</span>) : l1.next;</span><br><span class="line">                l2.next = (l2.next == <span class="keyword">null</span>) ? <span class="keyword">new</span> ListNode(<span class="number">0</span>) : l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            l1 = l1.next;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Time Complexity O(max(m,n))</p><p>Space Complexity O(max(m,n)) </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Leetcode-876-Middle-of-the-Linked-List&quot;&gt;&lt;a href=&quot;#Leetcode-876-Middle-of-the-Linked-List&quot; class=&quot;headerlink&quot; title=&quot;Leetcode 876 Middle of the Linked List&quot;&gt;&lt;/a&gt;Leetcode 876 Middle of the Linked List&lt;/h2&gt;&lt;p&gt;Given a non-empty, singly linked list with head node &lt;code&gt;head&lt;/code&gt;, return a middle node of linked list.&lt;/p&gt;
&lt;p&gt;If there are two middle nodes, return the second middle node.
    
    </summary>
    
      <category term="Leetcode" scheme="http://yoursite.com/categories/Leetcode/"/>
    
    
      <category term="LinkedList" scheme="http://yoursite.com/tags/LinkedList/"/>
    
      <category term="Leetcode-Easy" scheme="http://yoursite.com/tags/Leetcode-Easy/"/>
    
  </entry>
  
</feed>
